"""
PDF Exporter Module
Exports chapter summaries to formatted PDF files using fpdf2.
"""

import re
import io
from fpdf import FPDF


class SummaryPDFExporter:
    """Exports markdown summary text to a formatted PDF."""

    def export(
        self,
        chapter_title: str,
        chapter_info: str,
        summary_text: str,
        depth_label: str = "",
        book_title: str = "",
        media_items: list[dict] | None = None,
        chapter_start_page: int = 0,
        chapter_end_page: int = 0,
    ) -> bytes:
        """
        Export a summary to PDF bytes with inline images/tables.

        Args:
            chapter_title: Title of the chapter
            chapter_info: Page range info string
            summary_text: The markdown summary text
            depth_label: The depth level label (e.g., "Standard")
            book_title: Optional book title
            media_items: Optional list of media dicts with keys:
                         {type, bytes, description, page, label}
            chapter_start_page: Chapter start page (0-based)
            chapter_end_page: Chapter end page (0-based)

        Returns:
            PDF file as bytes
        """
        pdf = FPDF()
        pdf.set_auto_page_break(auto=True, margin=20)
        pdf.add_page()

        # ── Title Block ──
        pdf.set_font("Helvetica", "B", 22)
        pdf.set_text_color(33, 37, 41)
        pdf.cell(0, 12, self._clean(chapter_title), new_x="LMARGIN", new_y="NEXT")

        # Subtitle / meta info
        pdf.set_font("Helvetica", "", 10)
        pdf.set_text_color(108, 117, 125)
        meta_parts = []
        if book_title:
            meta_parts.append(self._clean(book_title))
        if chapter_info:
            meta_parts.append(self._clean(chapter_info))
        if depth_label:
            meta_parts.append(f"Depth: {self._clean(depth_label)}")
        if meta_parts:
            pdf.cell(0, 6, " | ".join(meta_parts), new_x="LMARGIN", new_y="NEXT")

        # Divider
        pdf.ln(4)
        pdf.set_draw_color(200, 200, 200)
        pdf.line(pdf.l_margin, pdf.get_y(), pdf.w - pdf.r_margin, pdf.get_y())
        pdf.ln(6)

        # ── Render content with inline media ──
        if media_items:
            self._render_with_inline_media(
                pdf, summary_text, media_items,
                chapter_start_page, chapter_end_page,
            )
        else:
            self._render_markdown(pdf, summary_text)

        # ── Footer ──
        pdf.ln(10)
        pdf.set_draw_color(200, 200, 200)
        pdf.line(pdf.l_margin, pdf.get_y(), pdf.w - pdf.r_margin, pdf.get_y())
        pdf.ln(4)
        pdf.set_font("Helvetica", "I", 8)
        pdf.set_text_color(150, 150, 150)
        pdf.cell(0, 5, "Generated by StudySage", align="C")

        return bytes(pdf.output())

    # ── Helpers ──────────────────────────────────────────────────────────────

    def _clean(self, text: str) -> str:
        """Remove emoji and normalize characters for built-in PDF fonts (latin-1)."""
        # Strip emoji ranges
        cleaned = re.compile(
            "["
            "\U0001f300-\U0001f9ff"
            "\U0001fa00-\U0001faff"
            "\U00002702-\U000027b0"
            "\U00002600-\U000026ff"
            "\U0000fe0f"
            "\U0000200d"
            "]+",
            flags=re.UNICODE,
        ).sub("", text)

        # Replace common Unicode chars with ASCII equivalents
        replacements = {
            "\u2013": "-",   # en-dash
            "\u2014": "--",  # em-dash
            "\u2018": "'",   # left single quote
            "\u2019": "'",   # right single quote
            "\u201c": '"',   # left double quote
            "\u201d": '"',   # right double quote
            "\u2026": "...", # ellipsis
            "\u2022": "-",   # bullet
            "\u2023": ">",   # triangular bullet
            "\u25cf": "-",   # black circle
            "\u25cb": "o",   # white circle
            "\u2713": "v",   # checkmark
            "\u2717": "x",   # ballot x
            "\u2192": "->",  # right arrow
            "\u2190": "<-",  # left arrow
        }
        for char, repl in replacements.items():
            cleaned = cleaned.replace(char, repl)

        # Final fallback — encode to latin-1, replacing anything unknown
        return cleaned.encode("latin-1", errors="replace").decode("latin-1")

    def _render_with_inline_media(
        self,
        pdf: FPDF,
        summary_text: str,
        media_items: list[dict],
        chapter_start_page: int = 0,
        chapter_end_page: int = 0,
    ):
        """
        Render summary markdown with media items interleaved at their
        correct positions based on page numbers.
        """
        # Split summary into sections by ## headings
        sections = re.split(r'(?=^## )', summary_text, flags=re.MULTILINE)
        sections = [s for s in sections if s.strip()]
        n_sections = max(len(sections), 1)

        ch_span = max(chapter_end_page - chapter_start_page, 1)

        # Map each media item to a section index
        media_by_section: dict[int, list[dict]] = {}
        for media in media_items:
            page_offset = media.get("page", chapter_start_page) - chapter_start_page
            section_idx = min(int((page_offset / ch_span) * n_sections), n_sections - 1)
            section_idx = max(0, section_idx)
            media_by_section.setdefault(section_idx, []).append(media)

        # Render each section followed by its media
        for s_idx, section_md in enumerate(sections):
            self._render_markdown(pdf, section_md)

            if s_idx in media_by_section:
                for media in media_by_section[s_idx]:
                    self._render_inline_media_item(pdf, media)

    def _render_inline_media_item(self, pdf: FPDF, media: dict):
        """Render a single media item (image or table) inline in the PDF."""
        pdf.ln(4)

        # Light border box
        pdf.set_draw_color(200, 200, 200)
        pdf.set_fill_color(250, 250, 250)

        # Label
        icon = "Table" if media.get("type") == "table" else "Figure"
        label = self._clean(media.get("label", icon))
        pdf.set_font("Helvetica", "B", 10)
        pdf.set_text_color(80, 80, 80)
        pdf.cell(0, 5, f"{icon}: {label}", new_x="LMARGIN", new_y="NEXT")
        pdf.ln(2)

        # Embed the image — centered, moderate size (max 120mm width)
        try:
            img_stream = io.BytesIO(media["bytes"])
            content_width = pdf.w - pdf.l_margin - pdf.r_margin
            img_width = min(content_width * 0.7, 120)  # ~70% width or 120mm
            x_offset = pdf.l_margin + (content_width - img_width) / 2
            pdf.image(img_stream, x=x_offset, w=img_width, h=0)
        except Exception:
            pdf.set_font("Helvetica", "I", 9)
            pdf.set_text_color(150, 50, 50)
            pdf.cell(0, 5, "[Image could not be embedded]", new_x="LMARGIN", new_y="NEXT")

        pdf.ln(2)

        # Description
        description = media.get("description", "")
        if description:
            pdf.set_font("Helvetica", "I", 9)
            pdf.set_text_color(80, 80, 80)
            cleaned_desc = self._clean(description)
            cleaned_desc = re.sub(r'\*\*(.*?)\*\*', r'\1', cleaned_desc)
            cleaned_desc = re.sub(r'`([^`]+)`', r'\1', cleaned_desc)
            pdf.multi_cell(0, 4.5, cleaned_desc)

        pdf.ln(5)

    # ── Markdown Renderer ────────────────────────────────────────────────────

    def _render_markdown(self, pdf: FPDF, text: str):
        """Parse markdown text and render formatted content to PDF."""
        lines = text.split("\n")
        in_code_block = False
        code_block_lines: list[str] = []

        for line in lines:
            # Code-block fences
            if line.strip().startswith("```"):
                if in_code_block:
                    self._render_code_block(pdf, code_block_lines)
                    code_block_lines = []
                    in_code_block = False
                else:
                    in_code_block = True
                continue

            if in_code_block:
                code_block_lines.append(line)
                continue

            stripped = line.strip()

            # Empty line
            if not stripped:
                pdf.ln(3)
                continue

            # Headings
            if stripped.startswith("#### "):
                self._render_heading(pdf, stripped[5:], level=4)
            elif stripped.startswith("### "):
                self._render_heading(pdf, stripped[4:], level=3)
            elif stripped.startswith("## "):
                self._render_heading(pdf, stripped[3:], level=2)
            elif stripped.startswith("# "):
                self._render_heading(pdf, stripped[2:], level=1)

            # Horizontal rule
            elif stripped in ("---", "***", "___"):
                pdf.ln(2)
                pdf.set_draw_color(200, 200, 200)
                pdf.line(pdf.l_margin, pdf.get_y(), pdf.w - pdf.r_margin, pdf.get_y())
                pdf.ln(4)

            # Bullet points (support up to 3 indent levels)
            elif re.match(r"^\s{4,8}[-*]\s", line):
                content = re.sub(r"^\s{4,8}[-*]\s", "", line)
                self._render_bullet(pdf, content, indent=2)
            elif re.match(r"^\s{2,4}[-*]\s", line):
                content = re.sub(r"^\s{2,4}[-*]\s", "", line)
                self._render_bullet(pdf, content, indent=1)
            elif re.match(r"^[-*]\s", stripped):
                self._render_bullet(pdf, stripped[2:], indent=0)

            # Numbered list
            elif re.match(r"^\d+\.\s", stripped):
                m = re.match(r"^(\d+\.)\s(.+)", stripped)
                if m:
                    self._render_numbered(pdf, m.group(1), m.group(2))

            # Regular paragraph
            else:
                self._render_paragraph(pdf, stripped)

    # ── Block renderers ──────────────────────────────────────────────────────

    def _render_heading(self, pdf: FPDF, text: str, level: int):
        sizes = {1: 18, 2: 15, 3: 13, 4: 11}
        size = sizes.get(level, 11)
        pdf.ln(4 if level <= 2 else 2)
        pdf.set_font("Helvetica", "B", size)
        pdf.set_text_color(33, 37, 41)
        pdf.multi_cell(0, size * 0.55, self._clean(text))
        pdf.ln(2)

    def _render_bullet(self, pdf: FPDF, text: str, indent: int = 0):
        left_offset = pdf.l_margin + (indent * 8)
        pdf.set_x(left_offset)
        pdf.set_font("Helvetica", "", 10)
        pdf.set_text_color(33, 37, 41)
        bullet = "-" if indent == 0 else (">" if indent == 1 else ".")
        pdf.cell(6, 5, bullet)
        self._write_rich_text(pdf, text, left_offset + 6)
        pdf.ln(2)

    def _render_numbered(self, pdf: FPDF, number: str, text: str):
        pdf.set_font("Helvetica", "B", 10)
        pdf.set_text_color(33, 37, 41)
        pdf.cell(10, 5, self._clean(number))
        self._write_rich_text(pdf, text, pdf.l_margin + 10)
        pdf.ln(2)

    def _render_paragraph(self, pdf: FPDF, text: str):
        pdf.set_font("Helvetica", "", 10)
        pdf.set_text_color(33, 37, 41)
        self._write_rich_text(pdf, text, pdf.l_margin)
        pdf.ln(3)

    def _render_code_block(self, pdf: FPDF, lines: list[str]):
        pdf.ln(2)
        pdf.set_fill_color(245, 245, 245)
        pdf.set_font("Courier", "", 9)
        pdf.set_text_color(50, 50, 50)
        for line in lines:
            cleaned = self._clean(line)
            pdf.set_x(pdf.l_margin + 4)
            pdf.cell(
                pdf.w - pdf.l_margin - pdf.r_margin - 8, 5,
                cleaned, fill=True, new_x="LMARGIN", new_y="NEXT",
            )
        pdf.ln(3)

    # ── Inline formatting ────────────────────────────────────────────────────

    def _write_rich_text(self, pdf: FPDF, text: str, x_start: float):
        """Write text with inline **bold** and `code` formatting."""
        pdf.set_x(x_start)

        # Split into segments: **bold**, `code`, or regular text
        pattern = r"(\*\*.*?\*\*|`[^`]+`)"
        segments = re.split(pattern, text)

        current_x = x_start
        line_height = 5
        max_width = pdf.w - pdf.r_margin

        for segment in segments:
            if not segment:
                continue

            if segment.startswith("**") and segment.endswith("**"):
                content = self._clean(segment[2:-2])
                pdf.set_font("Helvetica", "B", 10)
                pdf.set_text_color(33, 37, 41)
            elif segment.startswith("`") and segment.endswith("`"):
                content = self._clean(segment[1:-1])
                pdf.set_font("Courier", "", 9)
                pdf.set_text_color(200, 50, 50)
            else:
                content = self._clean(segment)
                pdf.set_font("Helvetica", "", 10)
                pdf.set_text_color(33, 37, 41)

            # Wrap to next line if needed
            text_width = pdf.get_string_width(content)
            if current_x + text_width > max_width and current_x > x_start + 5:
                pdf.ln(line_height)
                pdf.set_x(x_start)
                current_x = x_start

            pdf.write(line_height, content)
            current_x = pdf.get_x()

        pdf.ln(line_height)
